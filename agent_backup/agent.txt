"""
LLM-Driven Database Agent with Intelligent Decision Making

This module provides an intelligent database assistant that uses LLM to make decisions
about what actions to take based on user queries. It removes hardcoded logic and lets
the AI dynamically determine the best course of action for each interaction.
"""

from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, AIMessage, SystemMessage
from langchain_core.prompts import ChatPromptTemplate
from langgraph.graph import StateGraph, END
from langgraph.graph.message import add_messages
from typing import Dict, List, Any, Optional, TypedDict, Annotated
from sqlalchemy import create_engine, text, inspect, MetaData
from sqlalchemy.orm import sessionmaker
from sqlalchemy.exc import SQLAlchemyError
import os
from dotenv import load_dotenv
import json
import re
from datetime import datetime

load_dotenv()


class ConversationState(TypedDict):
    """State for the LangGraph conversation workflow."""
    messages: Annotated[List[Any], add_messages]
    next_action: Optional[str]
    context: Optional[Dict[str, Any]]


class DatabaseAgent:
    """
    LLM-Driven Database Agent with intelligent decision making.
    
    This agent uses LLM to dynamically decide what actions to take based on user queries,
    removing hardcoded logic and making the system more flexible and intelligent.
    """
    
    def __init__(self):
        """
        Initialize the LLM-Driven Database Agent.
        
        Sets up AI model, database connection, conversation history,
        and LLM-driven workflow for intelligent decision making.
        """
        # Initialize AI model
        self.llm = ChatOpenAI(
            model="gpt-4",
            api_key=os.getenv("OPENAI_API_KEY"),
            temperature=0.1
        )
        
        # Initialize database connection with error handling
        self.database_url = os.getenv("DATABASE_URL")
        if not self.database_url:
            raise ValueError("DATABASE_URL not found in environment variables. Please check your .env file.")
        
        try:
            self.engine = create_engine(self.database_url, echo=False)
            # Test connection
            with self.engine.connect() as conn:
                conn.execute(text("SELECT 1"))
            self.SessionLocal = sessionmaker(bind=self.engine, autocommit=False, autoflush=False)
        except Exception as e:
            raise ConnectionError(f"Failed to connect to database: {str(e)}. Please check your DATABASE_URL in .env file.")
        
        # Conversation history
        self.conversation_history: List[Dict[str, Any]] = []
        
        # System prompt for the AI
        self.system_prompt = """You are an intelligent database assistant that executes operations in real-time. You can:
1. Understand user queries in natural language
2. Execute SQL queries and database operations immediately
3. Perform real-time database modifications (ALTER, DROP, INSERT, UPDATE, DELETE)
4. Provide database insights and analysis
5. Remember conversation context for better responses

IMPORTANT: When users request database operations, execute them immediately in real-time.
Do not just talk about what you would do - actually perform the operations.
Be helpful, accurate, and explain what you've done after execution."""

        # Initialize LangGraph workflow
        self._setup_workflow()
    
    def _setup_workflow(self) -> None:
        """
        Set up LangGraph workflow for conversation management.
        
        Creates a simple state graph that uses LLM to decide next actions.
        """
        workflow = StateGraph(ConversationState)
        
        # Add nodes
        workflow.add_node("router", self._llm_router)
        workflow.add_node("database_operation", self._database_operation)
        workflow.add_node("response", self._generate_response)
        
        # Set entry point
        workflow.set_entry_point("router")
        
        # Add conditional edges based on LLM decision
        workflow.add_conditional_edges(
            "router",
            self._should_continue,
            {
                "database_operation": "database_operation",
                "response": "response",
                "end": END
            }
        )
        
        workflow.add_edge("database_operation", "response")
        workflow.add_edge("response", END)
        
        self.workflow = workflow.compile()
    
    def _llm_router(self, state: ConversationState) -> ConversationState:
        """
        Use LLM to decide what action to take next.
        
        Args:
            state: Current conversation state
            
        Returns:
            Updated state with next action decision
        """
        messages = state["messages"]
        last_message = messages[-1].content if messages else ""
        
        # Get conversation history for context
        history_context = ""
        if self.conversation_history:
            recent_history = self.conversation_history[-3:]  # Last 3 exchanges
            history_context = "\n".join([
                f"{entry['role']}: {entry['content']}" 
                for entry in recent_history
            ])
        
        router_prompt = f"""
You are a database assistant router. Based on the user's message, decide what action to take.

User message: {last_message}

Recent conversation:
{history_context}

Available actions:
- "database_operation": If the user wants to query, insert, update, delete, or get database info
- "response": If the user is asking for help, explanation, or general conversation
- "end": If the user wants to quit or end the conversation

Respond with ONLY the action name (database_operation, response, or end).
"""
        
        try:
            response = self.llm.invoke([
                SystemMessage(content="You are a routing assistant. Respond with only the action name."),
                HumanMessage(content=router_prompt)
            ])
            
            action = response.content.strip().lower()
            if action in ["database_operation", "response", "end"]:
                state["next_action"] = action
            else:
                state["next_action"] = "response"  # Default to response
                
        except Exception as e:
            state["next_action"] = "response"  # Default to response on error
        
        return state
    
    def _should_continue(self, state: ConversationState) -> str:
        """Return the next action based on LLM decision."""
        return state.get("next_action", "response")
    
    def _database_operation(self, state: ConversationState) -> ConversationState:
        """
        Handle database operations using LLM to understand and execute in real-time.
        
        Args:
            state: Current conversation state
            
        Returns:
            Updated state with operation results
        """
        messages = state["messages"]
        last_message = messages[-1].content if messages else ""
        
        # Get database info for context
        db_info = self.get_database_info()
        
        operation_prompt = f"""
You are a database assistant. The user wants to perform a database operation.

User message: {last_message}

Database structure:
{json.dumps(db_info, indent=2)}

Based on the user's request, you need to:
1. If it's a direct SQL query, execute it immediately
2. If it's a natural language request, convert it to SQL and execute it
3. If it's a request for database info, provide the information

IMPORTANT: You must actually execute SQL commands, not just talk about them.
For dangerous operations like DROP, ALTER, DELETE - execute them if the user confirms.

Respond with the actual results of the operation.
"""
        
        try:
            # First, let LLM analyze what needs to be done
            analysis_response = self.llm.invoke([
                SystemMessage(content="You are a database assistant. Analyze the user's request and determine what SQL operation to perform. Respond with ONLY the SQL query to execute, or 'INFO' if it's just a request for information."),
                HumanMessage(content=f"User request: {last_message}\nDatabase structure: {json.dumps(db_info, indent=2)}")
            ])
            
            sql_query = analysis_response.content.strip()
            
            # Check if it's a SQL query or info request
            if sql_query.upper().startswith(('SELECT', 'INSERT', 'UPDATE', 'DELETE', 'ALTER', 'DROP', 'CREATE')):
                # Execute the SQL query
                result = self.execute_sql_query(sql_query)
                
                if result.get("success"):
                    operation_result = f"âœ… Successfully executed SQL query:\n```sql\n{sql_query}\n```\n\nResult: {json.dumps(result, indent=2)}"
                else:
                    operation_result = f"âŒ Error executing SQL query:\n```sql\n{sql_query}\n```\n\nError: {result.get('error', 'Unknown error')}"
                    
            elif sql_query.upper() == 'INFO':
                # Provide database information
                operation_result = f"ğŸ“Š Database Information:\n{json.dumps(db_info, indent=2)}"
            else:
                # Let LLM handle other cases
                response = self.llm.invoke([
                    SystemMessage(content=self.system_prompt),
                    HumanMessage(content=operation_prompt)
                ])
                operation_result = response.content
            
            # Store the operation result in context
            state["context"] = {
                "operation_result": operation_result,
                "database_info": db_info,
                "sql_executed": sql_query if sql_query.upper().startswith(('SELECT', 'INSERT', 'UPDATE', 'DELETE', 'ALTER', 'DROP', 'CREATE')) else None
            }
            
        except Exception as e:
            state["context"] = {
                "operation_result": f"âŒ Error processing database operation: {str(e)}",
                "database_info": db_info
            }
        
        return state
    
    def _generate_response(self, state: ConversationState) -> ConversationState:
        """
        Generate final response using LLM with all context.
        
        Args:
            state: Current conversation state
            
        Returns:
            Updated state with final response
        """
        messages = state["messages"]
        last_message = messages[-1].content if messages else ""
        
        # Build comprehensive context
        context_parts = []
        
        if state.get("context"):
            if "operation_result" in state["context"]:
                context_parts.append(f"Database Operation Result: {state['context']['operation_result']}")
            if "database_info" in state["context"]:
                context_parts.append(f"Database Info: {json.dumps(state['context']['database_info'], indent=2)}")
        
        # Add conversation history
        if self.conversation_history:
            history_text = "\n".join([
                f"{entry['role']}: {entry['content']}" 
                for entry in self.conversation_history[-5:]
            ])
            context_parts.append(f"Recent Conversation:\n{history_text}")
        
        full_context = "\n\n".join(context_parts) if context_parts else "No additional context available."
        
        response_prompt = f"""
Context Information:
{full_context}

Current User Message: {last_message}

Provide a helpful, accurate, and context-aware response. 
If database operations were performed, explain the results clearly.
Use conversation history to provide better context.
"""
        
        try:
            response = self.llm.invoke([
                SystemMessage(content=self.system_prompt),
                HumanMessage(content=response_prompt)
            ])
            
            ai_response = response.content
            
            # Add to conversation history
            self._add_to_history("user", last_message)
            self._add_to_history("assistant", ai_response)
            
            # Add AI response to state
            state["messages"].append(AIMessage(content=ai_response))
            
        except Exception as e:
            error_response = f"Error generating response: {str(e)}"
            self._add_to_history("user", last_message)
            self._add_to_history("assistant", error_response)
            state["messages"].append(AIMessage(content=error_response))
        
        return state
    
    def _add_to_history(self, role: str, content: str) -> None:
        """
        Add message to conversation history.
        
        Args:
            role: Role of the speaker ('user' or 'assistant')
            content: Message content
        """
        self.conversation_history.append({
            "role": role,
            "content": content,
            "timestamp": datetime.now().isoformat()
        })
    
    def get_database_info(self) -> Dict[str, Any]:
        """
        Get comprehensive database information including tables, columns, and relationships.
        
        Returns:
            Dictionary containing database structure information
        """
        try:
            inspector = inspect(self.engine)
            tables = inspector.get_table_names()
            
            database_info = {
                "tables": {},
                "total_tables": len(tables),
                "database_url": self.database_url.split('@')[-1] if '@' in self.database_url else "Local database"
            }
            
            # Get detailed info for each table
            for table_name in tables:
                columns = inspector.get_columns(table_name)
                indexes = inspector.get_indexes(table_name)
                foreign_keys = inspector.get_foreign_keys(table_name)
                
                database_info["tables"][table_name] = {
                    "columns": [
                        {
                            "name": col["name"],
                            "type": str(col["type"]),
                            "nullable": col["nullable"],
                            "primary_key": col.get("primary_key", False),
                            "default": col.get("default")
                        } for col in columns
                    ],
                    "indexes": [{"name": idx["name"], "columns": idx["column_names"]} for idx in indexes],
                    "foreign_keys": [
                        {
                            "constrained_columns": fk["constrained_columns"],
                            "referred_table": fk["referred_table"],
                            "referred_columns": fk["referred_columns"]
                        } for fk in foreign_keys
                    ],
                    "row_count": self._get_table_row_count(table_name)
                }
            
            return database_info
            
        except Exception as e:
            return {"error": f"Failed to get database info: {str(e)}"}
    
    def _get_table_row_count(self, table_name: str) -> int:
        """
        Get row count for a specific table.
        
        Args:
            table_name: Name of the table
            
        Returns:
            Number of rows in the table
        """
        try:
            with self.engine.connect() as conn:
                result = conn.execute(text(f"SELECT COUNT(*) FROM {table_name}"))
                return result.scalar()
        except:
            return 0
    
    def execute_sql_query(self, query: str) -> Dict[str, Any]:
        """
        Execute a SQL query with real-time execution.
        
        Args:
            query: SQL query to execute
            
        Returns:
            Dictionary containing query results or error information
        """
        try:
            query_upper = query.upper().strip()
            
            with self.engine.connect() as conn:
                if query_upper.startswith('SELECT'):
                    # For SELECT queries, fetch and return data
                    result = conn.execute(text(query))
                    columns = result.keys()
                    rows = result.fetchall()
                    
                    return {
                        "success": True,
                        "columns": list(columns),
                        "data": [dict(row._mapping) for row in rows],
                        "row_count": len(rows),
                        "query_type": "SELECT"
                    }
                else:
                    # For other operations (INSERT, UPDATE, DELETE, ALTER, DROP, CREATE)
                    result = conn.execute(text(query))
                    conn.commit()
                    
                    return {
                        "success": True,
                        "message": "Query executed successfully",
                        "affected_rows": result.rowcount if hasattr(result, 'rowcount') else 0,
                        "query_type": query_upper.split()[0] if query_upper.split() else "UNKNOWN"
                    }
                        
        except SQLAlchemyError as e:
            return {
                "success": False,
                "error": f"Database error: {str(e)}",
                "query": query
            }
        except Exception as e:
            return {
                "success": False,
                "error": f"Unexpected error: {str(e)}",
                "query": query
            }
    
    def create_table(self, table_name: str, columns: List[Dict[str, str]]) -> Dict[str, Any]:
        """
        Create a new table with specified columns.
        
        Args:
            table_name: Name of the table to create
            columns: List of column definitions with name, type, and constraints
            
        Returns:
            Dictionary containing operation result
        """
        try:
            column_definitions = []
            for col in columns:
                col_def = f"{col['name']} {col['type']}"
                if col.get('primary_key'):
                    col_def += " PRIMARY KEY"
                if col.get('not_null'):
                    col_def += " NOT NULL"
                if col.get('unique'):
                    col_def += " UNIQUE"
                column_definitions.append(col_def)
            
            query = f"CREATE TABLE {table_name} ({', '.join(column_definitions)})"
            
            with self.engine.connect() as conn:
                conn.execute(text(query))
                conn.commit()
                
            return {
                "success": True,
                "message": f"Table '{table_name}' created successfully",
                "query": query
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": f"Failed to create table: {str(e)}"
            }
    
    def drop_table(self, table_name: str) -> Dict[str, Any]:
        """
        Drop a table from the database.
        
        Args:
            table_name: Name of the table to drop
            
        Returns:
            Dictionary containing operation result
        """
        try:
            query = f"DROP TABLE IF EXISTS {table_name}"
            
            with self.engine.connect() as conn:
                conn.execute(text(query))
                conn.commit()
                
            return {
                "success": True,
                "message": f"Table '{table_name}' dropped successfully"
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": f"Failed to drop table: {str(e)}"
            }
    
    def insert_data(self, table_name: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Insert data into a table.
        
        Args:
            table_name: Name of the table
            data: Dictionary of column names and values to insert
            
        Returns:
            Dictionary containing operation result
        """
        try:
            columns = list(data.keys())
            placeholders = ', '.join([':' + col for col in columns])
            
            query = f"INSERT INTO {table_name} ({', '.join(columns)}) VALUES ({placeholders})"
            
            with self.engine.connect() as conn:
                conn.execute(text(query), data)
                conn.commit()
                
            return {
                "success": True,
                "message": f"Data inserted into '{table_name}' successfully"
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": f"Failed to insert data: {str(e)}"
            }
    
    def update_data(self, table_name: str, data: Dict[str, Any], where_clause: str) -> Dict[str, Any]:
        """
        Update data in a table.
        
        Args:
            table_name: Name of the table
            data: Dictionary of column names and new values
            where_clause: WHERE condition for the update
            
        Returns:
            Dictionary containing operation result
        """
        try:
            set_clauses = ', '.join([f"{col} = :{col}" for col in data.keys()])
            query = f"UPDATE {table_name} SET {set_clauses} WHERE {where_clause}"
            
            with self.engine.connect() as conn:
                result = conn.execute(text(query), data)
                conn.commit()
                
            return {
                "success": True,
                "message": f"Data updated in '{table_name}' successfully",
                "affected_rows": result.rowcount
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": f"Failed to update data: {str(e)}"
            }
    
    def delete_data(self, table_name: str, where_clause: str) -> Dict[str, Any]:
        """
        Delete data from a table.
        
        Args:
            table_name: Name of the table
            where_clause: WHERE condition for the deletion
            
        Returns:
            Dictionary containing operation result
        """
        try:
            query = f"DELETE FROM {table_name} WHERE {where_clause}"
            
            with self.engine.connect() as conn:
                result = conn.execute(text(query))
                conn.commit()
                
            return {
                "success": True,
                "message": f"Data deleted from '{table_name}' successfully",
                "affected_rows": result.rowcount
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": f"Failed to delete data: {str(e)}"
            }
    
    def chat(self, user_input: str) -> str:
        """
        Main chat interface using LLM-driven workflow.
        
        Args:
            user_input: User's message or query
            
        Returns:
            Agent's response
        """
        try:
            # Create initial state
            initial_state = ConversationState(
                messages=[HumanMessage(content=user_input)],
                next_action=None,
                context=None
            )
            
            # Run through the workflow
            final_state = self.workflow.invoke(initial_state)
            
            # Get the last AI message
            ai_messages = [msg for msg in final_state["messages"] if isinstance(msg, AIMessage)]
            if ai_messages:
                return ai_messages[-1].content
            else:
                return "I'm sorry, I couldn't process your request. Please try again."
                
        except Exception as e:
            return f"âŒ Error: {str(e)}"
    
    def get_conversation_history(self) -> List[Dict[str, Any]]:
        """
        Get the conversation history.
        
        Returns:
            List of conversation entries with role, content, and timestamp
        """
        return self.conversation_history.copy()
    
    def clear_conversation_history(self) -> None:
        """Clear the conversation history."""
        self.conversation_history.clear()
    
    def get_help(self) -> str:
        """
        Get help information for the database agent.
        
        Returns:
            Formatted help text with available commands and examples
        """
        return """
ğŸ¤– **Real-Time Database Agent Help**

**How it works:**
- The AI executes database operations immediately in real-time
- No hardcoded rules - everything is dynamically determined by the LLM
- Natural language understanding with instant execution

**You can ask:**
- "Show me the database structure" â†’ Gets real database info
- "What tables do I have?" â†’ Queries database immediately
- "SELECT * FROM todos" â†’ Executes SQL instantly
- "Remove the priority column" â†’ Actually drops the column
- "Add a new table" â†’ Creates table in real-time

**Features:**
- ğŸš€ Real-time SQL execution
- ğŸ’¬ Natural language understanding
- ğŸ”„ Dynamic workflow routing
- ğŸ“Š Live database analysis
- âš¡ Instant operation execution
- ğŸ’­ Conversation memory

**Examples:**
- "What's in my database?" â†’ Shows actual database structure
- "Delete all completed tasks" â†’ Actually deletes the records
- "Add a new column" â†’ Modifies the table immediately

The AI executes your requests immediately - no more talking about what it would do!
"""


def main():
    """
    Main function to run the LLM-driven database agent.
    
    Initializes the agent, displays help information, and starts
    the interactive chat loop with intelligent decision making.
    """
    print("ğŸ¤– Real-Time Database Agent Starting...")
    print("=" * 60)
    
    try:
        agent = DatabaseAgent()
        print("âœ… Database connection established")
        print("âœ… AI model loaded")
        print("âœ… Real-time execution enabled")
        print("âœ… Immediate SQL execution ready")
        print("\n" + agent.get_help())
        
        print("\n" + "=" * 60)
        print("ğŸ’¬ Chat with your real-time database agent! (Type 'quit' to exit)")
        print("âš¡ The AI executes your requests immediately!")
        print("=" * 60)
        
        while True:
            user_input = input("\nğŸ‘¤ You: ").strip()
            
            if user_input.lower() in ['quit', 'exit', 'bye']:
                print("ğŸ‘‹ Goodbye! Thanks for using Real-Time Database Agent!")
                break
            
            if user_input.lower() == 'history':
                history = agent.get_conversation_history()
                print("\nğŸ“š **Conversation History:**")
                for entry in history[-10:]:  # Show last 10 entries
                    print(f"{entry['role'].title()}: {entry['content'][:100]}...")
                continue
            
            if user_input.lower() == 'clear':
                agent.clear_conversation_history()
                print("ğŸ§¹ Conversation history cleared!")
                continue
            
            if not user_input:
                continue
                
            print("\nğŸ¤– Agent: ", end="")
            response = agent.chat(user_input)
            print(response)
            
    except Exception as e:
        print(f"âŒ Failed to start Real-Time Database Agent: {str(e)}")
        print("Please check your database connection and API keys.")


if __name__ == "__main__":
    main()